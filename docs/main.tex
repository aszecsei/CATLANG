\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{libertine} % Normal text
\usepackage{DejaVuSansMono} % Code

\usepackage{listings} % For code environments

\usepackage[hidelinks]{hyperref}
\usepackage{xcolor}

% ========== DEFINE COLORS ==========
\definecolor{navy}{HTML}{001F3F}
\definecolor{blue}{HTML}{0074D9}
\definecolor{aqua}{HTML}{7FDBFF}
\definecolor{teal}{HTML}{39CCCC}
\definecolor{olive}{HTML}{3D9970}
\definecolor{green}{HTML}{2ECC40}
\definecolor{lime}{HTML}{01FF70}
\definecolor{yellow}{HTML}{FFDC00}
\definecolor{orange}{HTML}{FF851B}
\definecolor{red}{HTML}{FF4136}
\definecolor{maroon}{HTML}{85144B}
\definecolor{fuchsia}{HTML}{F012BE}
\definecolor{purple}{HTML}{B10DC9}
\definecolor{gray}{HTML}{AAAAAA}
\definecolor{silver}{HTML}{DDDDDD}

% ========== DEFINE LANGUAGE KEYWORDS ==========
\lstdefinelanguage{catlang}
{
	morekeywords = [1]{
		let,
		const,
		new,
		delete
		typeof,
		is,
		as,
		in,
		function,
		return,
		struct,
		SOA,
	},
	morekeywords = [2]{ % Control
		for,
		while,
		if,
		else,
	},
	morekeywords = [3]{ % Built-In Values
		true,
		false,
		null,
		any,
		S8,
		U8,
		S16,
		U16,
		S32,
		U32,
		S64,
		U64,
		char,
		int,
		long,
		bool,
		float,
		double,
		string,
		this,
	},
	keywordstyle = [1]\color{purple}\bfseries,
	keywordstyle = [2]\color{blue}\bfseries,
	keywordstyle = [3]\color{teal}\bfseries,
  	sensitive=true, % keywords are case-sensitive
  	morecomment=[l]{//}, % line comment
  	morecomment=[s]{/*}{*/}, % start and end delimeter
  	morestring=[b]",
  	morestring=[b]',
  	showstringspaces=false,
  	stringstyle=\color{red},
  	commentstyle=\color{gray}\itshape,
  	identifierstyle=\color{maroon},
}

\title{CatLang Design Doc}
\author{Alic Szecsei}

\begin{document}

\lstset{
	language=catlang,
	basicstyle=\footnotesize\ttfamily,
	breaklines=true,
}

\maketitle

\tableofcontents

\section{Background}

My goal with CatLang is to produce a programming language well-suited for low-level programming (such as game development) which includes many of the features common in more modern programming languages. I hardly propose that CatLang is a universal fix, but it seems like an engaging venture for my specific uses (and personal opinions about what a ``good programming language'' looks like).

A few notes about specific opinions I hold: \emph{kind} type-safety is important. Compilers should be able to infer as much as possible. Functions should be first-class; purely functional languages are too rigid, especially when performance is critical, but enabling programmers to use \emph{aspects} of functional languages seems the best of both worlds.

\section{Functions}

Functions can be defined in a C-like fashion:

\begin{lstlisting}
function timesTwo(num: int) -> int {
	return num * 2;
}
\end{lstlisting}

This is syntactically equivalent to a second, more functional approach:

\begin{lstlisting}
const timesTwo = (num: int) -> int {
	return num * 2;
}
\end{lstlisting}

\section{Typing}

CatLang uses strong typing, although some typing can be inferred. As an example:

\begin{lstlisting}
const timesTwo = (num) -> {
	return num * 2;
} // ERROR! Argument types cannot be inferred

const timesTwo = (num: int) -> {
	return num * 2;
} // OK!

const PI = 3.14159265; // OK!
\end{lstlisting}

\subsection{Type Unions}

Types can be composed through unions; this means that a value can be one of the listed types. For example:

\begin{lstlisting}
const falseIfEven = (num : int) -> {
	if (num % 2 == 0) {
		return false;
	}
	return num;
}
\end{lstlisting}

This method will return an object of type \lstinline!bool | int!; that is to say that it may be either a \lstinline!bool! or an \lstinline!int!, and CatLang cannot deterministically know which one it will be. Any further uses of the returned value must allow for \emph{both} possibilities, or CatLang will throw an error.

\section{Casting}

Casting is a way to check the type of an instance or to treat an instance of one type as another. There is no implicit casting in CatLang.

\subsection{Type Checking}

Type checking is performed with the \lstinline!is! operator:

\begin{lstlisting}
const x: int | string = otherFunction();
if (x is int) {
	print("This is an int!");
} else {
	print("This is a string!");
}
\end{lstlisting}

\subsection{Safe Casting}

Safe casting returns an optional type, equivalent to \lstinline!type | null!; safe casting must be evaluated at run-time. If run-time type information indicates that the variable's \emph{actual value} is of the casted type, the cast will succeed. Otherwise, the cast will return \lstinline!null!.

\begin{lstlisting}
const x: int | string = otherFunction();
const myFunc = (i: int) -> {
	// Something
}

myFunc(x); // ERROR!
myFunc(x as int); // ERROR!
if (let castX = x as int) {
	myFunc(castX); // OK
}
\end{lstlisting}

\subsection{Unsafe Casting}

Unsafe casting is used to force a cast from one value to another. While this can be used to avoid type lookups at run-time, it is not recommended for standard use. This is equivalent to a C-style cast.

\begin{lstlisting}
const x: long = 5000000000;
const y = x as! int; // 705032704
\end{lstlisting}

\section{Native Types}

\subsection{Primitives}

\begin{enumerate}
	\item Integer Numbers
	\begin{enumerate}
		\item \lstinline!S8! (1 byte, signed)
		\item \lstinline!U8! (1 byte, unsigned)
		\item \lstinline!S16! (2 bytes, signed)
		\item \lstinline!U16! (2 bytes, unsigned)
		\item \lstinline!S32! (4 byte, signed)
		\item \lstinline!U32! (4 byte, unsigned)
		\item \lstinline!S64! (8 byte, signed)
		\item \lstinline!U64! (8 byte, unsigned)
		\item \lstinline!char! (equivalent to U8)
		\item \lstinline!int! (equivalent to S32)
		\item \lstinline!long! (equivalent to S64)
	\end{enumerate}
	\item Booleans
	\begin{enumerate}
		\item \lstinline!bool! (1 byte)
	\end{enumerate}
	\item Floating-Point Numbers
	\begin{enumerate}
		\item \lstinline!float! (4 bytes)
		\item \lstinline!double! (8 bytes)
	\end{enumerate}
	\item Unvalued
	\begin{enumerate}
		\item \lstinline!null!
	\end{enumerate}
\end{enumerate}

\subsection{Any}

The \lstinline!any! type is the direct equivalent to C's \lstinline!void*! type.

\subsection{Optionals}

CatLang uses an ``optional'' type, equivalent to \lstinline!type | null!, to help avoid null-pointer exceptions. Any function that requires a non-Optional value must be enclosed in a conditional to ensure that the Optional value exists, or an error will be thrown.

\begin{lstlisting}
const myPrint = (num?: int) -> {
	if (num) {
		print(num);
	} else {
		print("Nope!");
	}
} // OK!

const myPrint2 = (num?: int) -> {
	print(num);
} // ERROR!
\end{lstlisting}

If a user wishes to force-unwrap an optional value, they can use the \lstinline$!$ operation to do so. This is, however, not recommended and may lead to null-pointer exceptions.

\begin{lstlisting}
const myPrint2 = (num?: int) -> {
	print(num!);
} // OK!
\end{lstlisting}

\subsection{Collections}

CatLang has two ways to combine data: arrays and structs.

\subsubsection{Arrays}

CatLang's arrays differ from C-style arrays in that they contain information about their length.

\begin{lstlisting}
const finalElement = myArray[myArray.length - 1];
\end{lstlisting}

Arrays also include convenience methods for a more functional style of programming; namely, \lstinline!map!, \lstinline!filter!, \lstinline!each!, and \lstinline!reduce!. They are instantiated using a syntax similar to C:

\begin{lstlisting}
const arr = [25]int;
\end{lstlisting}

Arrays can be either static- or dynamically-sized:

\begin{lstlisting}
const staticArray  = [25]int;
const dynamicArray = [..]int;
\end{lstlisting}

Arrays of pointers and pointers to arrays are syntactically different:

\begin{lstlisting}
const pointerToArray  : *[]int = @myArray;
const arrayOfPointers : []*int = myArray;
\end{lstlisting}

Arrays can be iterated over:

\begin{lstlisting}
const arr = []int { 1, 2, 3, 4, 5 };
for (x in arr) {
	print(x);
}
delete arr;
\end{lstlisting}

They can also iterate over inner properties of structs; in the following example, loops A and B are equivalent:

\begin{lstlisting}
struct Vector3 {
	x : float;
	y : float;
	z : float;
}
const arr = []Vector3 { ... };
for (xVal in arr.x) {
	print(xVal);
} // A
for (vec in arr) {
	print(vec.x);
} // B
\end{lstlisting}

\subsubsection{Strings}

CatLang's \lstinline!string! type is a wrapper around \lstinline!Array<char>!. A notable feature of the language is string interpolation:

\begin{lstlisting}
let name = "";
print("Enter your name: ");
readLine(name);
print("Hello, ${name}!\n");
\end{lstlisting}

\subsubsection{Structs}

CatLang's syntax for defining structures is straightforward:

\begin{lstlisting}
struct Vector3 {
	x : float;
	y : float;
	z : float;
}
\end{lstlisting}

Structs can also have default values assigned:

\begin{lstlisting}
struct Vector3 {
	x : float = 1.0;
	y : float = 2.0;
	z : float = 3.0;
}
\end{lstlisting}

To denote an ``owned'' property in a struct, use the \lstinline$!$ keyword. When a struct is deleted, all owned properties are also deleted.

\begin{lstlisting}
struct Transform {
	position : ! Vector3;
	rotation : ! Quaternion;
}
\end{lstlisting}

To allocate memory on the stack, users should declare variables \emph{without} the \lstinline!new! keyword. If the \lstinline!new! keyword is used, the variable is allocated on the heap and must be freed later with the \lstinline!delete! keyword.

\begin{lstlisting}
const v1 = Vector3; // Allocated on the stack.
const v2 = new Vector3; // Allocated on the heap...
delete v2; // ...so must be manually freed.
\end{lstlisting}

Structs can define how they are stored in arrays, in order to reduce cache misses. Structs default to the ``array of structs'' schema, but can be swapped to the ``struct of arrays'' schema using the \lstinline!SOA! keyword:

\begin{lstlisting}
struct V3A {
	x : float = 1;
	y : float = 2;
	z : float = 3;
}
let v1 = [4]V3A; // Memory will contain 1 2 3 1 2 3 1 2 3 1 2 3

struct V3B SOA {
	x : float = 1;
	y : float = 2;
	z : float = 3;
}
let v2 = [4]V3B; // Memory will contain 1 1 1 1 2 2 2 2 3 3 3 3
\end{lstlisting}

No matter how these arrays are stored in memory, they are used and referenced the same way within CatLang code.

Fields of a struct that begin with an underscore are private fields and are only accessible to functions within the struct's namespace. All other fields are public.

\begin{lstlisting}
struct MyStruct {
	_hiddenVar : string;
	publicVar : string;
}
\end{lstlisting}

\subsection{Functions}

Global functions are defined without any namespace.

\begin{lstlisting}
const timesTwo = (num: int) -> {
	return num * 2;
}
const value = timesTwo(4);
\end{lstlisting}

Static functions are attached to a struct, but not an instance of that struct. They \emph{cannot} use the keyword \lstinline!this! in their parameter list.

\begin{lstlisting}
Vector3::dot = (first: Vector3, other: Vector3) -> {
	return first.x * second.x + first.y * second.y + first.z * second.z;
}
const v1 = Vector3;
const v2 = Vector3;
const dot = Vector3::dot(v1, v2);
\end{lstlisting}

Instance functions are attached to an instance of a struct. They \emph{must} include the keyword \lstinline!this! as the first parameter.

\begin{lstlisting}
Vector3::toString = (this) -> {
	return "(${this.x}, ${this.y}, ${this.z})";
}
const v1 = Vector3;
print(v1.toString());
\end{lstlisting}

Functions attached to a struct, whether static or instance, are treated as immutable and cannot be redefined. The only way to overload a function is through the use of optional types.

Generic functions look similar to generics in other languages:

\begin{lstlisting}
const contains = <T>(arr: []T, value: T) -> {
	for (x in arr) {
		if (x == value) {
			return true;
		}
	}
	return false;
}
\end{lstlisting}

When generic functions are called, if the generic type can be inferred, it can be dropped:

\begin{lstlisting}
const arr = []int { 1, 2, 3, 4, 5 };
const result = contains(arr, 4);
\end{lstlisting}

However, if the generic type cannot be inferred, it must be made explicit:

\begin{lstlisting}
const arrayFactory = <T>(count: number) -> {
	return new [count]T;
}
const arr = arrayFactory(10); // ERROR!
const arr = arrayFactory<int>(10); // OK!
\end{lstlisting}

Functions can also be passed in to other functions, for a more functional style of programming. An example \lstinline!map! function might look like:

\begin{lstlisting}
const map = <InT, OutT>(arr: []T, fn: (InT)->OutT) -> {
	result = new [arr.count]OutT;
	for (x = 0; x < arr.count; x++) {
		result[x] = fn(arr[x]);
	}
	return result;
}
\end{lstlisting}

\subsection{Pointers}

Pointers can be retrieved from any struct or primitive. Optionals do not have pointers, although you can have an optional pointer. Functions can be called on pointers using the standard dot syntax, unlike C++'s arrow operator.

To retrieve the pointer to an object, use the \lstinline!@! operator. To retrieve an object from a pointer, use the \lstinline!*! operator.

\begin{lstlisting}
const myFunc = (x: *Vector3) -> {
	// This takes a pointer to a Vector3 struct
	print(x.toString()); // prints x as normal
}

const v = Vector3;
myFunc(@v);
\end{lstlisting}

Ownership works similarly with pointers:

\begin{lstlisting}
struct Transform {
	position : !*Vector3;
	rotation : !*Quaternion;
}
\end{lstlisting}

\section{Build System}

NOTE: THIS IS WORK-IN-PROGRESS

\end{document}