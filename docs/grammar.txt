<lexeme> ::= <identifier>
          |  <reserved word>
          |  <number>
          |  <string>
          |  <character>
          |  <punctuation>
          |  <end of file>

<identifier> ::= <letter> { <letter> | <digit> }
<number> ::= <decimal number> | 0x<hexadecimal number> | 0o<octal number> | 0b<binary number>

<decimal number> ::= <decimal integer> | <decimal float>
<decimal integer> ::= <digit> { <digit> }
<decimal float> ::= <digit> { <digit> } . { <digit> } /* Do we want to require a leading digit? ie is .27 a valid float? */

<hexadecimal number> ::= <hexadecimal digit> { <hexadecimal digit> }
<octal number> ::= <octal digit> { <octal digit> }
<binary number> ::= <binary digit> { <binary digit> }

<string> ::= '"' { <anything but "> } '"'
<character> ::= "'" <anything but \ or '> | '\' <anything> "'"

<punctuation> ::= "("
               |  ")"
               |  "{"
               |  "}"
               |  "["
               |  "]"
               |  ":"
               |  "::"
               |  ";"
               |  ","
               |  "@"
               |  "+"
               |  "+="
               |  "++"
               |  "-"
               |  "-="
               |  "--"
               |  "*"
               |  "*="
               |  "/"
               |  "/="
               |  "%"
               |  "%="
               |  "="
               |  "&&"
               |  "&="
               |  "||"
               |  "|"
               |  "|="
               |  "!"
               |  "^"
               |  "^="
               |  "<<"
               |  ">>"
               |  "=="
               |  "!="
               |  "<"
               |  ">"
               |  "<="
               |  ">="
               |  "->"
               |  "?"
               |  "."
               |  ".."

<reserved word> ::= "let"
                 |  "const"
                 |  "new"
                 |  "delete"
                 |  "typeof"
                 |  "is"
                 |  "as"
                 |  "in"
                 |  "function"
                 |  "return"
                 |  "struct"
                 |  "type"
                 |  "enum"
                 |  "owned"
                 |  "import"
                 |  "export"
                 |  "from"
                 |  "for"
                 |  "while"
                 |  "if"
                 |  "else"
                 |  "break"
                 |  "continue"
                 |  "this"

<catlang program> ::= <file> { <file> }

<file> ::= <block> <end of file>

<block> ::= { <block element> ";" }
<block element> ::= <declaration>
                 |  <statement>

<declaration> ::= [ <attribute> ] [ "export" ] <declarator>
<declarator> ::= <constant declarator>
              |  <type declarator>
              |  <variable declarator>
              |  <function declarator>
              |  <struct declarator>
              |  <enum declarator>

<attribute> ::= "#[" { <attribute list> "]"
<attribute list> ::= <attribute element> { "," <attribute element> }
<attribute element> ::= <ident> [ "(" <attribute parameter list> ")" ]
<attribute parameter list> ::= <attribute parameter> { "," <attribute parameter> }
<attribute parameter> ::= <expression>

<constant declarator> ::= "const" <identifier> "=" <expression>

<type declarator> ::= "typedef" <identifier> "=" <type>

<variable declarator> ::= "let" <identifier> ":" <type> [ "=" <expression> ]
                       |  "let" <identifier> "=" <expression>

<function declarator> ::= "function" <identifier> "(" [ <formal parameter list> ] ")" "{" <block> "}"
<formal parameter list> ::= "this" { "," <parameter> }
                         |  <parameter> { "," <parameter> }
<parameter> ::= [ "const" ] <identifier> ":" <type>

<struct declarator> ::= "struct" <identifier> "{" <struct parameter list> "}"
<struct parameter list> ::= { <parameter> [ ";" ] }
<struct parameter> ::= <identifier> ":" [ "owned" ] <type> [ "=" <expression> ]

<enum declarator> ::= "enum" <identifier> "{" <enum value list> "}"
<enum value list> ::= <identifier> { "," <identifier> }

<statement> ::= <import>
             |  <inner block>
             |  <if>
             |  <loop>
             |  <jump statement>
             |  <expression>


<import> ::= "import" <import list> "from" <string>
          |  "export" <import list> "from" <string>

<import list> ::= <import identifier> { "," <import identifier> }
<import identifier> ::= <identifier> [ "as" <identifier> ]
                     | "*" "as" <identifier>

<inner block> ::= "{" <block> "}"
<if> ::= "if" "(" <expression> ")" "{" <block> "}" { <elif> } [ <else> ]
<elif> ::= "else if" <expression> "{" <block> "}"
<else> ::= "else" "{" <block> "}"

<loop> ::= <for>
        |  <while>
        |  <do while>

<for> ::= "for" "(" [ <expression> ] ";" [ <expression> ] ";" [ <expression> ] ")" "{" <block> "}"
       |  "for" "(" <identifier> "in" <expression> ")" "{" <block> "}"
<while> ::= "while" "(" <expression> ")" "{" <block> "}"
<do while> ::= "do" "{" <block> "}" "while" "(" <expression> ")"

<jump statement> ::= "break"
                  |  "continue"
                  |  "return" [ <expression> ]

<type> ::= <pointer type>
        |  <sized array type>
        |  <unsized array type>
        |  <type union>
        |  <typeof expression>
        |  <optional type>
        |  <named type>

<pointer type> ::= "*" <type>
<sized array type> ::= "[" <expression> "]" <type>
<unsized array type> ::= "[" ".." "]" <type>
<type union> ::= <type> { "|" <type> }
<typeof expression> ::= "typeof" <expression>
<optional type> ::= <type> "?"
<named type> ::= <identifier>


<expression> ::= <assignment expression>

<assignment expression> ::= [ <identifier> <assignment operator> ] <ternary expression>
<ternary expression> ::= <comparing expression> [ "?" <comparing expression> ":" <comparing expression> ]
<comparing expression> ::= <comparand> [<comparing operator> <comparand>]
<comparand> ::= <term> ::= { <adding operator> <term> }
<term> ::= <factor> { <multiplying operator> <factor> }

<comparing operator> ::= "=="
                      |  "!="
                      |  ">"
                      |  ">="
                      |  "<"
                      |  "<="
                      |  "in"
                      |  "is"

<adding operator> ::= "+" [ "=" ]
                   |  "-" [ "=" ]
                   |  "|" [ "=" ]
                   |  "^" [ "=" ]
                   |  "||"

<multiplying operator> ::= "*" [ "=" ]
                        |  "/" [ "=" ]
                        |  "%" [ "=" ]
                        |  "&" [ "=" ]
                        |  "&&"

<factor> ::= [ "-" | "!" ] <primary expression>

<primary expression> ::= <number>
                      |  <string constant>
                      |  "null"
                      |  <subexpression>
                      |  <lambda expression>
                      |  <reference>

<subexpression> ::= "(" <expression> ")"
<lambda expression> ::= "(" [ <formal parameter list> ] ")" "->" "{" <block> "}"
<reference> ::= <identifier>
             |  "this"
             |  "@" <reference> /* address-of operator */
             |  "*" <reference> /* pointer dereferencing */
             |  <reference> "." <identifier>
             |  <function call>
             |  <constructor call>
             |  <array reference>
             |  <cast reference>

<function call> ::= <reference> "(" [ <expressions> ] ")"
<constructor call> ::= [ "new" ] <type> [ "(" [ <expressions> ] ")" ]
<array reference> ::= <reference> "[" <expressions> "]"
<cast reference> ::= <reference> "as" [ "!" ] <type>

<expression list> ::= <expression> { "," <expression> }